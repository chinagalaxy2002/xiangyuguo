<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜çº§ 3D åœ°çƒ - éƒ­ç¿”è£•</title>
    <meta name="description" content="ä½¿ç”¨ Three.js åˆ›å»ºçš„é«˜çº§ 3D åœ°çƒæ•ˆæœ">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            background: #000000;
            overflow: hidden;
            color: white;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .info-overlay {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 30px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            max-width: 350px;
        }
        
        .info-overlay h1 {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        
        .info-overlay p {
            font-size: 0.9em;
            color: #b0c0d0;
            line-height: 1.6;
            margin-bottom: 8px;
        }
        
        .back-link {
            display: inline-block;
            margin-top: 15px;
            padding: 8px 20px;
            background: linear-gradient(135deg, #5588ff 0%, #4ecdc4 100%);
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            transition: transform 0.3s;
        }
        
        .back-link:hover {
            transform: translateY(-2px);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #4ecdc4;
            z-index: 5;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .info-overlay {
                top: 20px;
                left: 20px;
                right: 20px;
                padding: 15px 20px;
                max-width: none;
            }
            
            .info-overlay h1 {
                font-size: 1.4em;
            }
            
            .info-overlay p {
                font-size: 0.85em;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="info-overlay">
        <h1>ğŸŒ é«˜çº§ 3D åœ°çƒ</h1>
        <p>â€¢ æ‹–æ‹½é¼ æ ‡æ—‹è½¬åœ°çƒ</p>
        <p>â€¢ æ»šåŠ¨é¼ æ ‡æ»šè½®ç¼©æ”¾</p>
        <p>â€¢ åœ°çƒä¼šè‡ªåŠ¨ç¼“æ…¢æ—‹è½¬</p>
        <p>â€¢ çœŸå®çš„åœ°çƒçº¹ç†è´´å›¾</p>
        <a href="index.html" class="back-link">è¿”å›ä¸»é¡µ</a>
    </div>
    
    <div class="loading" id="loading">åŠ è½½ä¸­...</div>
    
    <!-- å¼•å…¥ Three.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, earth, atmosphere, clouds;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let isDragging = false;
        let previousMouseX = 0, previousMouseY = 0;
        
        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            const container = document.getElementById('canvas-container');
            const loading = document.getElementById('loading');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 3;
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // æ·»åŠ ç‚¹å…‰æº
            const pointLight = new THREE.PointLight(0xffffff, 1.2);
            pointLight.position.set(5, 3, 5);
            scene.add(pointLight);
            
            // åˆ›å»ºåœ°çƒ
            createEarth();
            
            // åˆ›å»ºå¤§æ°”å±‚
            createAtmosphere();
            
            // éšè—åŠ è½½æç¤º
            loading.style.display = 'none';
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬
            addEventListeners();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
        }
        
        // åˆ›å»ºåœ°çƒ
        function createEarth() {
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            
            // åˆ›å»ºçº¹ç†åŠ è½½å™¨
            const textureLoader = new THREE.TextureLoader();
            
            // ç”±äºå®é™…çº¹ç†å›¾ç‰‡å¯èƒ½ä¸å¯ç”¨ï¼Œæˆ‘ä»¬ä½¿ç”¨ç¨‹åºåŒ–çº¹ç†
            // åˆ›å»ºåŸºç¡€æè´¨
            const material = new THREE.MeshPhongMaterial({
                color: 0x2233ff,
                emissive: 0x112244,
                specular: 0x333333,
                shininess: 25,
                bumpScale: 0.05
            });
            
            // å°è¯•åŠ è½½çœŸå®çº¹ç†ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            textureLoader.load(
                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/textures/planets/earth_atmos_2048.jpg',
                (texture) => {
                    material.map = texture;
                    material.needsUpdate = true;
                },
                undefined,
                (error) => {
                    console.log('ä½¿ç”¨é»˜è®¤è“è‰²åœ°çƒæè´¨');
                }
            );
            
            // å°è¯•åŠ è½½å‡¹å‡¸è´´å›¾
            textureLoader.load(
                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/textures/planets/earth_normal_2048.jpg',
                (texture) => {
                    material.bumpMap = texture;
                    material.needsUpdate = true;
                },
                undefined,
                (error) => {
                    console.log('å‡¹å‡¸è´´å›¾åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                }
            );
            
            // å°è¯•åŠ è½½é«˜å…‰è´´å›¾
            textureLoader.load(
                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/textures/planets/earth_specular_2048.jpg',
                (texture) => {
                    material.specularMap = texture;
                    material.needsUpdate = true;
                },
                undefined,
                (error) => {
                    console.log('é«˜å…‰è´´å›¾åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                }
            );
            
            earth = new THREE.Mesh(geometry, material);
            scene.add(earth);
        }
        
        // åˆ›å»ºå¤§æ°”å±‚
        function createAtmosphere() {
            const geometry = new THREE.SphereGeometry(1.05, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4488ff,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            
            atmosphere = new THREE.Mesh(geometry, material);
            scene.add(atmosphere);
        }
        
        // æ·»åŠ äº‹ä»¶ç›‘å¬
        function addEventListeners() {
            // çª—å£å¤§å°æ”¹å˜
            window.addEventListener('resize', onWindowResize, false);
            
            // é¼ æ ‡äº‹ä»¶
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            
            // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯æ”¯æŒï¼‰
            document.addEventListener('touchstart', onTouchStart, false);
            document.addEventListener('touchmove', onTouchMove, false);
            document.addEventListener('touchend', onTouchEnd, false);
            
            // é¼ æ ‡æ»šè½®ç¼©æ”¾
            document.addEventListener('wheel', onWheel, false);
        }
        
        // çª—å£å¤§å°æ”¹å˜å¤„ç†
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // é¼ æ ‡ç§»åŠ¨
        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                // é™åˆ¶Xè½´æ—‹è½¬èŒƒå›´
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
                
                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            } else {
                // é¼ æ ‡è·Ÿéšæ•ˆæœï¼ˆè½»å¾®ï¼‰
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            }
        }
        
        function onMouseDown(event) {
            isDragging = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        // è§¦æ‘¸äº‹ä»¶å¤„ç†
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                isDragging = true;
                previousMouseX = event.touches[0].clientX;
                previousMouseY = event.touches[0].clientY;
            }
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1 && isDragging) {
                const deltaX = event.touches[0].clientX - previousMouseX;
                const deltaY = event.touches[0].clientY - previousMouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
                
                previousMouseX = event.touches[0].clientX;
                previousMouseY = event.touches[0].clientY;
            }
        }
        
        function onTouchEnd() {
            isDragging = false;
        }
        
        // é¼ æ ‡æ»šè½®ç¼©æ”¾
        function onWheel(event) {
            event.preventDefault();
            camera.position.z += event.deltaY * 0.001;
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            camera.position.z = Math.max(1.5, Math.min(5, camera.position.z));
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            if (earth && atmosphere) {
                // è‡ªåŠ¨æ—‹è½¬
                if (!isDragging) {
                    earth.rotation.y += 0.001;
                    atmosphere.rotation.y += 0.0012;
                    
                    // è½»å¾®çš„é¼ æ ‡è·Ÿéšæ•ˆæœ
                    camera.position.x += (mouseX * 0.1 - camera.position.x) * 0.05;
                    camera.position.y += (mouseY * 0.1 - camera.position.y) * 0.05;
                } else {
                    // å¹³æ»‘æ—‹è½¬åˆ°ç›®æ ‡è§’åº¦
                    earth.rotation.y += (targetRotationY - earth.rotation.y) * 0.1;
                    earth.rotation.x += (targetRotationX - earth.rotation.x) * 0.1;
                    atmosphere.rotation.y = earth.rotation.y;
                    atmosphere.rotation.x = earth.rotation.x;
                }
                
                camera.lookAt(scene.position);
            }
            
            renderer.render(scene, camera);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
